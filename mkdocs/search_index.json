{
    "docs": [
        {
            "location": "/",
            "text": "API-INDEX\n\n\nMODULE: Element\n\n\nsetposition(at::Element.Atom,  R::Tuple{Float64, Float64, Float64})\n  \nsetposition(at,R)\n\n\nElement.Atom\n  \nAtom(Z; R=(0.,0.,0.), params...)\n\n\nElement.Molecule\n  \nMolecule(; atoms=[], params...)\n\n\nElement.MultipoleFunc{T}\n  Multipole function \n\n\nElement.RadialFunc{T}\n  Spherically symmetric function \n\n\nanalytic_continuation!(r::AbstractArray{T, 1},  f::AbstractArray{T, 1},  g::Function)\n  \nanalytic_continuation!(r,f,g)\n\n\nanalytic_continuation(r,  f,  g)\n  \nanalytic_continuation(r,f,g)\n\n\nanalytic_continuation_coulomb_nuclei!(r::AbstractArray{Float64, 1},  f::AbstractArray{Float64, 2},  l::AbstractArray{Int64, 1})\n  \nanalytic_continuation_coulomb_nuclei!(r,f,l)\n\n\ndeepcopy(at::Element.Atom,  R::Tuple{Float64, Float64, Float64})\n  \ndeepcopy(at,R)\n\n\neig!(u::Array{Float64, 1},  v::Array{Array{Float64, 1}, 1},  aE::Function,  dx::Float64,  qmin::Integer,  qmax::Integer)\n  \neig!(u,v,aE,dx,qmin,qmax;Emin=0.0,Emax=1.0,Elim=10000.)\n\n\neig(aE::Function,  dx::Float64,  qmin::Integer,  qmax::Integer)\n  \neig(aE,dx,qmin,qmax;Emin=0.0,Emax=1.0,Elim=10000.)\n\n\nenumeratelm(lmax)\n  \nenumeratelm(lmax)\n lists all pairs \n(l,m)\n for \nl=0,...,lmax\n and \nm=-l,...,l\n.\n\n\nfindsteps!(I::Array{Tuple{Float64, Float64}, 1},  f::Function,  xl::Float64,  xr::Float64,  fmin::Int64,  fmax::Int64)\n  \nfindsteps!(I,f,xl,xr,[fmin,fmax];args=())\n \n\n\nfindsteps(f::Function,  xl::Float64,  xr::Float64)\n  \nfindsteps(f,xl,xr,[fmin,fmax];args=())\n \n\n\nfzero(f,  x1::Float64,  x2::Float64,  args...)\n  \nfzero(f,x1,x2,args...;tol=1e-12,maxsteps=100)\n\n\ngenOh_a00(v)\n   C version: Dmitri Laikov\n\n\nmultipolemoment(r,  rho,  l)\n  \nmultipolemoment(r,rho,l)\n\n\nmultistep_integrator!(y::AbstractArray{Float64, 1},  a::AbstractArray{Float64, 1},  h::Float64,  y1::Float64,  y2::Float64)\n  \nmultistep_integrator!(y,a,h,y1,y2)\n is the same as \nmultistep_integrator\n,\n\n\nmultistep_integrator(a::AbstractArray{Float64, 1},  h::Float64,  y1::Float64,  y2::Float64)\n  \nmultistep_integrator(a,h,y1,y2)\n solves \n\n\nmultistep_integrator_endpoint(y::AbstractArray{Float64, 1},  a::AbstractArray{Float64, 1},  h::Float64,  y1::Float64,  y2::Float64)\n  \nmultistep_integrator_endpoint(y,a,h,y1,y2)\n \n\n\nmultistep_integrator_node_count(y::AbstractArray{Float64, 1},  a::AbstractArray{Float64, 1},  h::Float64,  y1::Float64,  y2::Float64)\n  \nmultistep_integrator_node_count(y,a,h,y1,y2)\n \n\n\nmultistep_rule(a_jm1::Float64,  a_j::Float64,  a_jp1::Float64,  y_jm1::Float64,  y_j::Float64,  h::Float64)\n  \nmultistep_rule(a_jm1,a_j,a_jp1,y_jm1,y_j,h)\n\n\nradpoisson(r::Element.LogarithmicGrid{T, A\n:AbstractArray{T, 1}},  rho::AbstractArray{T, 1},  l::Int64)\n  \nradpoisson(r,rho,l)\n\n\nradschrod(r::Element.LogarithmicGrid{Float64, A\n:AbstractArray{T, 1}},  v::AbstractArray{Float64, 1},  nmax::Int64,  lmax::Int64)\n  \nradschrod(r,v,nmax,lmax;reverse=false,Emin=-1.0,Emax=0.0,Elim=1e4)\n\n\nradschrod1(r::Element.UniformGrid{Float64, A\n:AbstractArray{T, 1}},  v::AbstractArray{Float64, 1},  n::Int64,  l::Int64)\n  \nradschrod1(r,v,n,l;reverse=false,Emin=-1.0,Emax=0.0,Elim=1e4)\n\n\nrealsphharm(l::Int64,  m::Int64,  \u03b8::Real,  \u03d5::Real)\n  \nrealsphharm(l,m,\u03b8,\u03d5)\n\n\nsphharm(l::Int64,  m::Int64,  \u03b8::Real,  \u03d5::Real)\n  \nsphharm(l,m,\u03b8,\u03d5)\n\n\nsplineradial!(at::Element.Atom)\n  \nsplineradial!(at; npts=100)\n\n\nElement.CoulombPotential\n  \nCoulombPotential(Z;R=(0.,0.,0.))\n\n\nElement.ldaxc\n  \nldaxc\n is the pw-lda exchange-correlation functional [1,2].",
            "title": "Index"
        },
        {
            "location": "/#api-index",
            "text": "",
            "title": "API-INDEX"
        },
        {
            "location": "/#module-element",
            "text": "setposition(at::Element.Atom,  R::Tuple{Float64, Float64, Float64})    setposition(at,R)  Element.Atom    Atom(Z; R=(0.,0.,0.), params...)  Element.Molecule    Molecule(; atoms=[], params...)  Element.MultipoleFunc{T}   Multipole function   Element.RadialFunc{T}   Spherically symmetric function   analytic_continuation!(r::AbstractArray{T, 1},  f::AbstractArray{T, 1},  g::Function)    analytic_continuation!(r,f,g)  analytic_continuation(r,  f,  g)    analytic_continuation(r,f,g)  analytic_continuation_coulomb_nuclei!(r::AbstractArray{Float64, 1},  f::AbstractArray{Float64, 2},  l::AbstractArray{Int64, 1})    analytic_continuation_coulomb_nuclei!(r,f,l)  deepcopy(at::Element.Atom,  R::Tuple{Float64, Float64, Float64})    deepcopy(at,R)  eig!(u::Array{Float64, 1},  v::Array{Array{Float64, 1}, 1},  aE::Function,  dx::Float64,  qmin::Integer,  qmax::Integer)    eig!(u,v,aE,dx,qmin,qmax;Emin=0.0,Emax=1.0,Elim=10000.)  eig(aE::Function,  dx::Float64,  qmin::Integer,  qmax::Integer)    eig(aE,dx,qmin,qmax;Emin=0.0,Emax=1.0,Elim=10000.)  enumeratelm(lmax)    enumeratelm(lmax)  lists all pairs  (l,m)  for  l=0,...,lmax  and  m=-l,...,l .  findsteps!(I::Array{Tuple{Float64, Float64}, 1},  f::Function,  xl::Float64,  xr::Float64,  fmin::Int64,  fmax::Int64)    findsteps!(I,f,xl,xr,[fmin,fmax];args=())    findsteps(f::Function,  xl::Float64,  xr::Float64)    findsteps(f,xl,xr,[fmin,fmax];args=())    fzero(f,  x1::Float64,  x2::Float64,  args...)    fzero(f,x1,x2,args...;tol=1e-12,maxsteps=100)  genOh_a00(v)    C version: Dmitri Laikov  multipolemoment(r,  rho,  l)    multipolemoment(r,rho,l)  multistep_integrator!(y::AbstractArray{Float64, 1},  a::AbstractArray{Float64, 1},  h::Float64,  y1::Float64,  y2::Float64)    multistep_integrator!(y,a,h,y1,y2)  is the same as  multistep_integrator ,  multistep_integrator(a::AbstractArray{Float64, 1},  h::Float64,  y1::Float64,  y2::Float64)    multistep_integrator(a,h,y1,y2)  solves   multistep_integrator_endpoint(y::AbstractArray{Float64, 1},  a::AbstractArray{Float64, 1},  h::Float64,  y1::Float64,  y2::Float64)    multistep_integrator_endpoint(y,a,h,y1,y2)    multistep_integrator_node_count(y::AbstractArray{Float64, 1},  a::AbstractArray{Float64, 1},  h::Float64,  y1::Float64,  y2::Float64)    multistep_integrator_node_count(y,a,h,y1,y2)    multistep_rule(a_jm1::Float64,  a_j::Float64,  a_jp1::Float64,  y_jm1::Float64,  y_j::Float64,  h::Float64)    multistep_rule(a_jm1,a_j,a_jp1,y_jm1,y_j,h)  radpoisson(r::Element.LogarithmicGrid{T, A :AbstractArray{T, 1}},  rho::AbstractArray{T, 1},  l::Int64)    radpoisson(r,rho,l)  radschrod(r::Element.LogarithmicGrid{Float64, A :AbstractArray{T, 1}},  v::AbstractArray{Float64, 1},  nmax::Int64,  lmax::Int64)    radschrod(r,v,nmax,lmax;reverse=false,Emin=-1.0,Emax=0.0,Elim=1e4)  radschrod1(r::Element.UniformGrid{Float64, A :AbstractArray{T, 1}},  v::AbstractArray{Float64, 1},  n::Int64,  l::Int64)    radschrod1(r,v,n,l;reverse=false,Emin=-1.0,Emax=0.0,Elim=1e4)  realsphharm(l::Int64,  m::Int64,  \u03b8::Real,  \u03d5::Real)    realsphharm(l,m,\u03b8,\u03d5)  sphharm(l::Int64,  m::Int64,  \u03b8::Real,  \u03d5::Real)    sphharm(l,m,\u03b8,\u03d5)  splineradial!(at::Element.Atom)    splineradial!(at; npts=100)  Element.CoulombPotential    CoulombPotential(Z;R=(0.,0.,0.))  Element.ldaxc    ldaxc  is the pw-lda exchange-correlation functional [1,2].",
            "title": "MODULE: Element"
        },
        {
            "location": "/Element/",
            "text": "Element\n\n\n\n\n\n\nsetposition(at::Element.Atom,  R::Tuple{Float64, Float64, Float64}) \n\u00b6\n\n\nsetposition(at,R)\n\n\nsets the position of atom \nat\n to \nR\n\n\nsource:\n\n\nElement/src/atom.jl:109\n\n\n\n\n\n\nElement.Atom \n\u00b6\n\n\nAtom(Z; R=(0.,0.,0.), params...)\n\n\ncreates an atom at \nR\n with nuclear charge \nZ\n,\nwith any additional parameters \nparams\n.\n\n\nsource:\n\n\nElement/src/atom.jl:10\n\n\n\n\n\n\nElement.Molecule \n\u00b6\n\n\nMolecule(; atoms=[], params...)\n\n\ncreates an molecules with \natoms\n.\n\n\nsource:\n\n\nElement/src/molecule.jl:9\n\n\n\n\n\n\nElement.MultipoleFunc{T} \n\u00b6\n\n\nMultipole function \n\n\n\n\nf_{lm}(r,\\theta,\\phi) = u(r) Y_{lm}(\\theta,\\phi)\n,\n\n\nwhere \nu(r)\n is a user-defined radial function.\n\n\nIf \nr_{cut}<r<r_{max}\n, then the long-range analytical\nform \nq Y_{lm}(\\theta,\\phi)/r^{l+1}\n is used, where\n\nq\n is the multipole moment.\n\n\nThe function vanishes for \nr>r_{max}\n.\n\n\nf = MultipoleFunc(u; l=0, m=0, R=(0.,0.,0.), rcut=Inf, rmax=Inf, q=0.)\n\n\nu\n - a user-defined radial function\n\n\ne.g.\n\n\nu = r -\n exp(-r^2)\nu = Spline1D(r, exp(-r.^2))\n\n\n\n\nl\n,\nm\n - angular quantum numbers\n\n\nR\n - origin of spherical coordinate system\n\n\nsource:\n\n\nElement/src/multipole.jl:32\n\n\n\n\n\n\nElement.RadialFunc{T} \n\u00b6\n\n\nSpherically symmetric function \n\n\n\n\nf(r,\\theta,\\phi) = u(r)\n\n\n\n\nwhere \nu(r)\n is a user-defined radial function.\n\n\nThe function vanishes for \nr>r_{max}\n.\n\n\nf = RadialFunc(u; R=(0.,0.,0.), rmax=Inf)\n\n\nu\n - a user-defined radial function\n\n\nR\n - origin of spherical coordinate system\n\n\nsource:\n\n\nElement/src/radialfunc.jl:19\n\n\n\n\n\n\nanalytic_continuation!(r::AbstractArray{T, 1},  f::AbstractArray{T, 1},  g::Function) \n\u00b6\n\n\nanalytic_continuation!(r,f,g)\n\n\nsame as \nanalytic_continuation\n but mutates \nf\n.\n\n\nsource:\n\n\nElement/src/radschrod.jl:152\n\n\n\n\n\n\nanalytic_continuation(r,  f,  g) \n\u00b6\n\n\nanalytic_continuation(r,f,g)\n\n\nsmoothly replaces \nf(r)\n with the analytic form given by \ng(r)\n as \nr\\to 0\n\n\n\n\nthe transition point is determined as the point where \nthe derivatives of \nf\n and \ng\n match.\n\n\nanalytic continuation as \nr\\to\\infty\n can be acheived by reversing\n\nr\n and \nf\n.\n\n\ne.g.\n\n\nr = loggrid(-12,4.,1000)\nn,l = 3,1\nev,ef = radschrod1(r,-1./r,n,l,reverse=true)\nefc = analytic_continuation(r,ef,r -\n r.^(l+1))\n\n\n\n\nsource:\n\n\nElement/src/radschrod.jl:180\n\n\n\n\n\n\nanalytic_continuation_coulomb_nuclei!(r::AbstractArray{Float64, 1},  f::AbstractArray{Float64, 2},  l::AbstractArray{Int64, 1}) \n\u00b6\n\n\nanalytic_continuation_coulomb_nuclei!(r,f,l)\n\n\nanalytically continues multiple functions \nf(r)\n  (columns of \nf\n) with\nthe analytic form \nr^{l+1}\n as \nr\\to 0\n.\n\n\nf\n - a matrix whose columns are functions of \nr\n\n\nl\n - corresponding \nl\n-quantum numbers\n\n\nsource:\n\n\nElement/src/radschrod.jl:198\n\n\n\n\n\n\ndeepcopy(at::Element.Atom,  R::Tuple{Float64, Float64, Float64}) \n\u00b6\n\n\ndeepcopy(at,R)\n\n\nreturns a copy of \nat\n at the position \nR\n\n\nsource:\n\n\nElement/src/atom.jl:131\n\n\n\n\n\n\neig!(u::Array{Float64, 1},  v::Array{Array{Float64, 1}, 1},  aE::Function,  dx::Float64,  qmin::Integer,  qmax::Integer) \n\u00b6\n\n\neig!(u,v,aE,dx,qmin,qmax;Emin=0.0,Emax=1.0,Elim=10000.)\n\n\nsame as \neig\n except that the eigenvalues and eigenfunctions are appended to \nu\n \nand \nv\n, respectively.\n\n\nreturns \nq\n, the number of nodes in the eigenfunctions.\n\n\nsource:\n\n\nElement/src/eig.jl:174\n\n\n\n\n\n\neig(aE::Function,  dx::Float64,  qmin::Integer,  qmax::Integer) \n\u00b6\n\n\neig(aE,dx,qmin,qmax;Emin=0.0,Emax=1.0,Elim=10000.)\n\n\nsolves the eigenvalue equation \n\n\n\n\ny''(x) + a_E(x) y(x) = 0\n\n\n\n\nvia the shooting method and Numerov's multistep integrator (see \nmultistep_integrator\n),\non a uniform grid \n[x_1, \\dots, x_n]\n with spacing \ndx\n\nand boundary conditions \ny(x_1) = 0\n and \ny(x_n) = 0\n,\n\n\naE\n - the function \na_E(x)\n, which returns a vector \n[a_E(x_1), \\dots, a_E(x_n)]\n\nfor a given value of \nE\n.\n\n\nqmin,qmax\n - solve for eigenfunctions with \nqmin \n q \n qmax\n nodes.\n\n\nEmin,Emax\n - initial \nE\n interval to search. this will be expanded automatically\n (up to \n\u00b1Elim\n) until the range includes all requested eigenvalues.\n\n\nreturns \n(u,v,q)\n\n\nwhere \nu\n are the eigenvalues, \nv\n are the eigenfunctions (the jth\neigenfunction given by \nv[:,j]\n), and \nq\n are the respective number of nodes in\nthe eigenfunctions.\n\n\ne.g. \nparticle in a box\n\n\nx = lingrid(0,1,100)\ndx = x[2]-x[1]\nv = zeros(x)\nevs,efs,q = eig(E -\n 2*(E-v),dx,0,4)\n\n\n\n\nsource:\n\n\nElement/src/eig.jl:146\n\n\n\n\n\n\nenumeratelm(lmax) \n\u00b6\n\n\nenumeratelm(lmax)\n lists all pairs \n(l,m)\n for \nl=0,...,lmax\n and \nm=-l,...,l\n.\n\n\nsource:\n\n\nElement/src/multipole.jl:65\n\n\n\n\n\n\nfindsteps!(I::Array{Tuple{Float64, Float64}, 1},  f::Function,  xl::Float64,  xr::Float64,  fmin::Int64,  fmax::Int64) \n\u00b6\n\n\nfindsteps!(I,f,xl,xr,[fmin,fmax];args=())\n \n\n\nlike \nfindsteps\n except that the intervals \n(x_l,x_r)\n are appended to \nI\n.\n\n\nsource:\n\n\nElement/src/findsteps.jl:35\n\n\n\n\n\n\nfindsteps(f::Function,  xl::Float64,  xr::Float64) \n\u00b6\n\n\nfindsteps(f,xl,xr,[fmin,fmax];args=())\n \n\n\ntakes a function \nf(x,args...)\n, assumed to be a\nmonotonically increasing integer function of \nx\n.\n\n\noptionally one can specify the range of \nf\n to search \nwith \nfmin\n, \nfmax\n\n\nperforms a binary search and returns an ordered list of \nintervals \n[(x_{l,1},x_{r,1}),(x_{l,2},x_{r,2}),\\dots]\n\nwithin the specificed range \n(xl,xr)\n which contains exactly one step.\n\n\ne.g.\n\n\nf = (x,c) -\n round(Int,x^2+c)\nfindsteps(f,0.0,2.0,args=1.0)\n\n\n\n\nsource:\n\n\nElement/src/findsteps.jl:69\n\n\n\n\n\n\nfzero(f,  x1::Float64,  x2::Float64,  args...) \n\u00b6\n\n\nfzero(f,x1,x2,args...;tol=1e-12,maxsteps=100)\n\n\nfinds the root \nx_0\n of \nf(x)\n in the interval \n[x_1,x_2]\n, such that\n\nf(x_0) = 0\n (up to specified tolerance \ntol\n).\n\n\nf\n - a function f(x,args...) that returns Float64, where extra parameters \nmay be passed through to \nf\n.\n\n\nthrows an error if \nf(x_1)\n and \nf(x_2)\n have the same sign, or \nif more than \nmaxsteps\n iterations are taken.\n\n\nuses the Dekker-Brent method (see \nNumerical Recipes in C\n, p. 361).\n\n\nsource:\n\n\nElement/src/fzero.jl:17\n\n\n\n\n\n\ngenOh_a00(v) \n\u00b6\n\n\nC version: Dmitri Laikov\n F77 version: Christoph van Wuellen, http://www.ccl.net\n Python version: Richard P. Muller, 2002.\n Julia version: John C. Snyder, 2015.\n\n\nThis subroutine is part of a set of subroutines that generate\n Lebedev grids [1-6] for integration on a sphere. The original \n C-code [1] was kindly provided by Dr. Dmitri N. Laikov and \n translated into fortran by Dr. Christoph van Wuellen.\n This subroutine was translated from C to fortran77 by hand.\n\n\nUsers of this code are asked to include reference [1] in their\n publications, and in the user- and programmers-manuals \n describing their codes.\n\n\n[1] V.I. Lebedev, and D.N. Laikov\n       'A quadrature formula for the sphere of the 131st\n        algebraic order of accuracy'\n       Doklady Mathematics, Vol. 59, No. 3, 1999, pp. 477-481.\n\n\n[2] V.I. Lebedev\n       'A quadrature formula for the sphere of 59th algebraic\n        order of accuracy'\n       Russian Acad. Sci. Dokl. Math., Vol. 50, 1995, pp. 283-286. \n\n\n[3] V.I. Lebedev, and A.L. Skorokhodov\n       'Quadrature formulas of orders 41, 47, and 53 for the sphere'\n       Russian Acad. Sci. Dokl. Math., Vol. 45, 1992, pp. 587-592. \n\n\n[4] V.I. Lebedev\n       'Spherical quadrature formulas exact to orders 25-29'\n       Siberian Mathematical Journal, Vol. 18, 1977, pp. 99-107. \n\n\n[5] V.I. Lebedev\n       'Quadratures on a sphere'\n       Computational Mathematics and Mathematical Physics, Vol. 16,\n       1976, pp. 10-24. \n\n\n[6] V.I. Lebedev\n       'Values of the nodes and weights of ninth to seventeenth \n        order Gauss-Markov quadrature formulae invariant under the \n        octahedron group with inversion'\n       Computational Mathematics and Mathematical Physics, Vol. 15,\n       1975, pp. 44-51.\n\n\nsource:\n\n\nElement/src/lebedev.jl:49\n\n\n\n\n\n\nmultipolemoment(r,  rho,  l) \n\u00b6\n\n\nmultipolemoment(r,rho,l)\n\n\ncomputes the multipole moment of radial density \nrho\n in\nthe \nl\n-angular momentum channel\n\n\n\n\nq = \\int dr\\, r^{l+2} \\rho_{lm}(r)\n.\n\n\nr\n (LogarithmicGrid) - logarithmic grid (\nloggrid\n)\n\n\nrho\n (AbstractVector) - radial density \n\\rho_{lm}(r)\n evaluated on \nr\n \n\n\nl\n (Int) - l-quantum number\n\n\nsource:\n\n\nElement/src/radpoisson.jl:70\n\n\n\n\n\n\nmultistep_integrator!(y::AbstractArray{Float64, 1},  a::AbstractArray{Float64, 1},  h::Float64,  y1::Float64,  y2::Float64) \n\u00b6\n\n\nmultistep_integrator!(y,a,h,y1,y2)\n is the same as \nmultistep_integrator\n,\nbut overwrites \ny\n.\n\n\nsource:\n\n\nElement/src/eig.jl:22\n\n\n\n\n\n\nmultistep_integrator(a::AbstractArray{Float64, 1},  h::Float64,  y1::Float64,  y2::Float64) \n\u00b6\n\n\nmultistep_integrator(a,h,y1,y2)\n solves \n\n\n\n\ny''(x) + a(x) y(x) = 0\n\n\n\n\non a uniform grid via the 4th order \n\nNumerov's method\n.\n\n\nAssuming a uniform grid \n[x_1, \\dots, x_n]\n with spacing \nh\n\n\na\n - discretization of \na(x)\n, \n[a(x_1), \\dots, a(x_n)]\n\n\n\n\ny1,y2\n - initial boundary condition, specifying \ny(x_1)\n and \ny(x_2)\n\n\n\n\nReturns the solution \n[y(x_1), \\dots, y(x_n)]\n.\n\n\nsource:\n\n\nElement/src/eig.jl:48\n\n\n\n\n\n\nmultistep_integrator_endpoint(y::AbstractArray{Float64, 1},  a::AbstractArray{Float64, 1},  h::Float64,  y1::Float64,  y2::Float64) \n\u00b6\n\n\nmultistep_integrator_endpoint(y,a,h,y1,y2)\n \n\n\nis the same as \nmultistep_integrator\n,\nbut returns only \ny(x_n)\n. \n\n\ny\n is used as temporary storage.\n\n\nsource:\n\n\nElement/src/eig.jl:63\n\n\n\n\n\n\nmultistep_integrator_node_count(y::AbstractArray{Float64, 1},  a::AbstractArray{Float64, 1},  h::Float64,  y1::Float64,  y2::Float64) \n\u00b6\n\n\nmultistep_integrator_node_count(y,a,h,y1,y2)\n \n\n\nis the same as \nmultistep_integrator\n,\nbut returns the number of nodes in \ny(x)\n (i.e. the number of sign changes). \n\n\ny\n is used as temporary storage.\n\n\nsource:\n\n\nElement/src/eig.jl:78\n\n\n\n\n\n\nmultistep_rule(a_jm1::Float64,  a_j::Float64,  a_jp1::Float64,  y_jm1::Float64,  y_j::Float64,  h::Float64) \n\u00b6\n\n\nmultistep_rule(a_jm1,a_j,a_jp1,y_jm1,y_j,h)\n\n\ncomputes the multistep rule in Numerov's method:\n\n\n\n\ny_{j+1} = { \\left(2-5h^2 a_j/6\\right)y_j - \\left(1+h^2 a_{j-1}/12\\right)y_{j-1} \n    \\over 1+h^2 a_{j+1}/12 }\n\n\n\n\nsource:\n\n\nElement/src/eig.jl:12\n\n\n\n\n\n\nradpoisson(r::Element.LogarithmicGrid{T, A\n:AbstractArray{T, 1}},  rho::AbstractArray{T, 1},  l::Int64) \n\u00b6\n\n\nradpoisson(r,rho,l)\n\n\nsolves the poisson equation for a radial density \nrho\n in\nthe \nl\n-angular momentum channel\n\n\ncomputes the hartree potential\n\n\n\n\nv_{h,lm}(r) = \\int_0^r dr_<\\, r_<^2 g_l(r_<,r) \\rho_{lm}(r_<) + \n    \\int_r^\\infty dr_>\\, r_>^2 g_l(r,r_>) \\rho_{lm}(r_>)\n,\n\n\nwhere \ng_l(r_<,r_>) = r_<^l/r_>^{l+1}\n\n\n\n\nuses a 3rd order adams-moulton multistep integrator to compute\neach integral\n\n\nr\n (LogarithmicGrid) - logarithmic grid (\nloggrid\n)\n\n\nrho\n (AbstractVector) - radial density \n\\rho_{lm}(r)\n evaluated on \nr\n \n\n\nl\n (Int) - l-quantum number\n\n\ne.g.\n\n\nl = 0\nr = loggrid(-13,5,100)\nrho = exp(-2r)\nvh = radpoisson(r,rho,l)\nq = multipolemoment(r,rho,l)\nplot(r,vh)\nplot!(r,q./r.^(l+1))  # asymptotic form of hartree potential\nxlims!(0,10)\nylims!(0,0.3)\n\n\n\n\n[\nV. Blum et al., CPC 180 (2009)\n p. 2185-2186]\n\n\nsource:\n\n\nElement/src/radpoisson.jl:41\n\n\n\n\n\n\nradschrod(r::Element.LogarithmicGrid{Float64, A\n:AbstractArray{T, 1}},  v::AbstractArray{Float64, 1},  nmax::Int64,  lmax::Int64) \n\u00b6\n\n\nradschrod(r,v,nmax,lmax;reverse=false,Emin=-1.0,Emax=0.0,Elim=1e4)\n\n\nsolves the radial Schr\u00f6dinger equation\n\n\n\n\n\\left\\{ -{1\\over 2}{d^2\\over dr^2} + {l(l+1)\\over 2r^2} + v(r) \\right\\} u(r) = \\epsilon u(r)\n\n\n\n\nwhere \n\\varphi(r,\\Omega) = {u(r)\\over r} Y_l^m(\\Omega)\n.\n\n\nfor all eigenvalues/eigenfunctions up to \nnmax,lmax\n (\nnmax \n 0\n, \nlmax \n= 0\n and \nlmax \n nmax\n).\n\n\nthe eigenfunctions are normalized such that \n\\int dr\\, u(r)^2 = 1\n\n\n\n\nr\n - logarithmic grid (see \nloggrid\n)\n\n\nv\n - the radial potential \nv(r)\n evaluated on the grid \nr\n\n\nreverse\n - if true, integrate in reverse. \n\n\nEmin,Emax\n - initial \nE\n interval to search. this will be expanded automatically\n (up to \n\u00b1Elim\n) until the range includes all requested eigenvalues.\n\n\nreturns \nevs,efs,q\n, the requested eigenvalues, eigenfunctions and a list of \nthe corresponding quantum numbers \nn,l\n\n\ne.g. \nhydrogenic atom, Z=1\n\n\nr = loggrid(-12,5,1000)\nv = -1./r\nnmax,lmax = 3,2\nevs,efs,q = radschrod(r,v,nmax,lmax,reverse=true)\n\n\n\n\nsource:\n\n\nElement/src/radschrod.jl:113\n\n\n\n\n\n\nradschrod1(r::Element.UniformGrid{Float64, A\n:AbstractArray{T, 1}},  v::AbstractArray{Float64, 1},  n::Int64,  l::Int64) \n\u00b6\n\n\nradschrod1(r,v,n,l;reverse=false,Emin=-1.0,Emax=0.0,Elim=1e4)\n\n\nsolves the radial Schr\u00f6dinger equation\n\n\n\n\n\\left\\{ -{1\\over 2}{d^2\\over dr^2} + {l(l+1)\\over 2r^2} + v(r) \\right\\} u(r) = \\epsilon u(r)\n\n\n\n\nwhere \n\\varphi(r,\\Omega) = {u(r)\\over r} Y_l^m(\\Omega)\n.\n\n\nfor a single eigenvalue/eigenfunction, specified by \nn,l\n. \n\n\nthe eigenfunction is normalized such that \n\\int dr\\, u(r)^2 = 1\n\n\n\n\nr\n - uniform grid (\nlingrid\n, \nsimpsgrid\n) or logarithmic grid (\nloggrid\n)\n\n\nv\n - the radial potential \nv(r)\n evaluated on the grid \nr\n\n\nreverse\n - if true, integrate in reverse. \n\n\nEmin,Emax\n - initial \nE\n interval to search. this will be expanded automatically\n (up to \n\u00b1Elim\n) until the range includes all requested eigenvalues.\n\n\nreturns \nev,ef\n, the requested eigenvalue \n\\epsilon\n and the eigenfunction \nu(r)\n\n\n\n\ne.g. \nhydrogen atom 1s orbital\n\n\nr = loggrid(-12,4,500)\nv = -1./r\nev,ef = radschrod1(r,v,1,0,reverse=true)\n\n\n\n\nsource:\n\n\nElement/src/radschrod.jl:49\n\n\n\n\n\n\nrealsphharm(l::Int64,  m::Int64,  \u03b8::Real,  \u03d5::Real) \n\u00b6\n\n\nrealsphharm(l,m,\u03b8,\u03d5)\n\n\ncomputes the real spherical harmonic function\n\n\n\n\n Y_{lm} = {i \\over \\sqrt{2}} \\left(Y_l^m - (-1)^m Y_l^{-m}\\right), \\quad m<0 \n\n\n\n\n\n\n Y_{lm} = Y_l^m, \\quad m=0 \n\n\n\n\n\n\n Y_{lm} = {1 \\over \\sqrt{2}} \\left(Y_l^{-m} + (-1)^m Y_l^m\\right), \\quad m>0 \n\n\n\n\nsource:\n\n\nElement/src/sphharm.jl:48\n\n\n\n\n\n\nsphharm(l::Int64,  m::Int64,  \u03b8::Real,  \u03d5::Real) \n\u00b6\n\n\nsphharm(l,m,\u03b8,\u03d5)\n\n\ncomputes the spherical harmonic function (standard definition used in quantum mechanics)\n\n\n\n\n Y_l^m(\\theta,\\phi) = (-1)^m \\sqrt{{2l+1 \\over 4\\pi} {(l-m)!\\over (l+m)!}} P_l^m(cos \\theta) e^{im\\phi} \n\n\n\n\nwhich are normalized such that \n\n\n\n\n \\int Y_l^m(\\theta,\\phi)^* Y_{l'}^{m'}(\\theta,\\phi) d\\Omega = \\delta_{ll'} \\delta_{mm'} \n\n\n\n\nsource:\n\n\nElement/src/sphharm.jl:32\n\n\n\n\n\n\nsplineradial!(at::Element.Atom) \n\u00b6\n\n\nsplineradial!(at; npts=100)\n\n\nsplines the electronic density \nrho\n, hartree potential \nvh\n,\nand Kohn-Sham potential \nvs\n and creates radial functions.\nAdditionally, the Coulomb potential \nv\n is created.\n\n\nassumes the \nrho\n, \nvh\n and \nvs\n have been calculated and are\ngiven in \nat\n discretized on the radial grid \nr\n.\n\n\nsets\n\n\nat[:v]\n (see \nCoulombPotential\n)\n\n\nat[:rho]\n, \nat[:vh]\n, \nat[:vs]\n (see \nRadialFunc\n).\n\n\nnpts\n - the number of evenly distributed spline points to use\n\n\ne.g.\n\n\nat = dft(Z=1.)\nsplineradial!(at)\nplot(at[:rho].u,0,5,label=\nrho\n)\nplot!(at[:vh].u,0,5,label=\nvh\n)\nplot!(at[:vs].u,0,5,label=\nvs\n)\nylims!(-2,1)\n\n\n\n\nsource:\n\n\nElement/src/atom.jl:170\n\n\n\n\n\n\nElement.CoulombPotential \n\u00b6\n\n\nCoulombPotential(Z;R=(0.,0.,0.))\n\n\nrepresents the Coulomb potential \nv(r) = -Z/|r-R|\n\n\n\n\nsource:\n\n\nElement/src/coulomb.jl:8\n\n\n\n\n\n\nElement.ldaxc \n\u00b6\n\n\nldaxc\n is the pw-lda exchange-correlation functional [1,2].\n\n\ncalls the functionals \nXC_LDA_X\n, \nXC_LDA_C_PW_MOD\n in \nlibxc\n.\n\n\nspin-polarized and spin-unpolarized versions \ncan be created via \nldaxcpol()\n and \nldaxcunpol()\n\n\ne.g.\n\n\nxc = ldaxcunpol()\n\nvx = xc.x.v(rho)  # exchange potential\nex = xc.x.e(rho)  # exchange energy density\nvc = xc.c.v(rho)  # correlation potential\nec = xc.c.e(rho)  # correlation energy density\n\n# in-place versions\nxc.x.v(rho,vx)\nxc.x.e(rho,ex)\nxc.c.v(rho,vc)\nxc.c.e(rho,ec)\n\n# more efficient to compute both together\nxc.x(rho,ex,vx)\nxc.c(rho,ec,vc)\n\n# compute all components\nxc(rho,ex,vx,ec,vc)\n\n\n\n\n[1] J. P. Perdew and Y. Wang. Accurate and simple analytic representation \nof the electron-gas correlation energy. Phys. Rev. B, 45:13244\u201313249, 1992.\n\n\n[2] D. M. Ceperley and B. J. Alder. Ground state of the electron gas by \na stochastic method. Phys. Rev. Lett., 45:566\u2013569, 1980.\n\n\nsource:\n\n\nElement/src/xc.jl:177",
            "title": "Element"
        },
        {
            "location": "/Element/#element",
            "text": "",
            "title": "Element"
        },
        {
            "location": "/Element/#setpositionatelementatom-rtuplefloat64-float64-float64",
            "text": "setposition(at,R)  sets the position of atom  at  to  R  source:  Element/src/atom.jl:109",
            "title": "setposition(at::Element.Atom,  R::Tuple{Float64, Float64, Float64}) \u00b6"
        },
        {
            "location": "/Element/#elementatom",
            "text": "Atom(Z; R=(0.,0.,0.), params...)  creates an atom at  R  with nuclear charge  Z ,\nwith any additional parameters  params .  source:  Element/src/atom.jl:10",
            "title": "Element.Atom \u00b6"
        },
        {
            "location": "/Element/#elementmolecule",
            "text": "Molecule(; atoms=[], params...)  creates an molecules with  atoms .  source:  Element/src/molecule.jl:9",
            "title": "Element.Molecule \u00b6"
        },
        {
            "location": "/Element/#elementmultipolefunct",
            "text": "Multipole function    f_{lm}(r,\\theta,\\phi) = u(r) Y_{lm}(\\theta,\\phi) ,  where  u(r)  is a user-defined radial function.  If  r_{cut}<r<r_{max} , then the long-range analytical\nform  q Y_{lm}(\\theta,\\phi)/r^{l+1}  is used, where q  is the multipole moment.  The function vanishes for  r>r_{max} .  f = MultipoleFunc(u; l=0, m=0, R=(0.,0.,0.), rcut=Inf, rmax=Inf, q=0.)  u  - a user-defined radial function  e.g.  u = r -  exp(-r^2)\nu = Spline1D(r, exp(-r.^2))  l , m  - angular quantum numbers  R  - origin of spherical coordinate system  source:  Element/src/multipole.jl:32",
            "title": "Element.MultipoleFunc{T} \u00b6"
        },
        {
            "location": "/Element/#elementradialfunct",
            "text": "Spherically symmetric function    f(r,\\theta,\\phi) = u(r)   where  u(r)  is a user-defined radial function.  The function vanishes for  r>r_{max} .  f = RadialFunc(u; R=(0.,0.,0.), rmax=Inf)  u  - a user-defined radial function  R  - origin of spherical coordinate system  source:  Element/src/radialfunc.jl:19",
            "title": "Element.RadialFunc{T} \u00b6"
        },
        {
            "location": "/Element/#analytic_continuationrabstractarrayt-1-fabstractarrayt-1-gfunction",
            "text": "analytic_continuation!(r,f,g)  same as  analytic_continuation  but mutates  f .  source:  Element/src/radschrod.jl:152",
            "title": "analytic_continuation!(r::AbstractArray{T, 1},  f::AbstractArray{T, 1},  g::Function) \u00b6"
        },
        {
            "location": "/Element/#analytic_continuationr-f-g",
            "text": "analytic_continuation(r,f,g)  smoothly replaces  f(r)  with the analytic form given by  g(r)  as  r\\to 0   the transition point is determined as the point where \nthe derivatives of  f  and  g  match.  analytic continuation as  r\\to\\infty  can be acheived by reversing r  and  f .  e.g.  r = loggrid(-12,4.,1000)\nn,l = 3,1\nev,ef = radschrod1(r,-1./r,n,l,reverse=true)\nefc = analytic_continuation(r,ef,r -  r.^(l+1))  source:  Element/src/radschrod.jl:180",
            "title": "analytic_continuation(r,  f,  g) \u00b6"
        },
        {
            "location": "/Element/#analytic_continuation_coulomb_nucleirabstractarrayfloat64-1-fabstractarrayfloat64-2-labstractarrayint64-1",
            "text": "analytic_continuation_coulomb_nuclei!(r,f,l)  analytically continues multiple functions  f(r)   (columns of  f ) with\nthe analytic form  r^{l+1}  as  r\\to 0 .  f  - a matrix whose columns are functions of  r  l  - corresponding  l -quantum numbers  source:  Element/src/radschrod.jl:198",
            "title": "analytic_continuation_coulomb_nuclei!(r::AbstractArray{Float64, 1},  f::AbstractArray{Float64, 2},  l::AbstractArray{Int64, 1}) \u00b6"
        },
        {
            "location": "/Element/#deepcopyatelementatom-rtuplefloat64-float64-float64",
            "text": "deepcopy(at,R)  returns a copy of  at  at the position  R  source:  Element/src/atom.jl:131",
            "title": "deepcopy(at::Element.Atom,  R::Tuple{Float64, Float64, Float64}) \u00b6"
        },
        {
            "location": "/Element/#eiguarrayfloat64-1-varrayarrayfloat64-1-1-aefunction-dxfloat64-qmininteger-qmaxinteger",
            "text": "eig!(u,v,aE,dx,qmin,qmax;Emin=0.0,Emax=1.0,Elim=10000.)  same as  eig  except that the eigenvalues and eigenfunctions are appended to  u  \nand  v , respectively.  returns  q , the number of nodes in the eigenfunctions.  source:  Element/src/eig.jl:174",
            "title": "eig!(u::Array{Float64, 1},  v::Array{Array{Float64, 1}, 1},  aE::Function,  dx::Float64,  qmin::Integer,  qmax::Integer) \u00b6"
        },
        {
            "location": "/Element/#eigaefunction-dxfloat64-qmininteger-qmaxinteger",
            "text": "eig(aE,dx,qmin,qmax;Emin=0.0,Emax=1.0,Elim=10000.)  solves the eigenvalue equation    y''(x) + a_E(x) y(x) = 0   via the shooting method and Numerov's multistep integrator (see  multistep_integrator ),\non a uniform grid  [x_1, \\dots, x_n]  with spacing  dx \nand boundary conditions  y(x_1) = 0  and  y(x_n) = 0 ,  aE  - the function  a_E(x) , which returns a vector  [a_E(x_1), \\dots, a_E(x_n)] \nfor a given value of  E .  qmin,qmax  - solve for eigenfunctions with  qmin   q   qmax  nodes.  Emin,Emax  - initial  E  interval to search. this will be expanded automatically\n (up to  \u00b1Elim ) until the range includes all requested eigenvalues.  returns  (u,v,q)  where  u  are the eigenvalues,  v  are the eigenfunctions (the jth\neigenfunction given by  v[:,j] ), and  q  are the respective number of nodes in\nthe eigenfunctions.  e.g.  particle in a box  x = lingrid(0,1,100)\ndx = x[2]-x[1]\nv = zeros(x)\nevs,efs,q = eig(E -  2*(E-v),dx,0,4)  source:  Element/src/eig.jl:146",
            "title": "eig(aE::Function,  dx::Float64,  qmin::Integer,  qmax::Integer) \u00b6"
        },
        {
            "location": "/Element/#enumeratelmlmax",
            "text": "enumeratelm(lmax)  lists all pairs  (l,m)  for  l=0,...,lmax  and  m=-l,...,l .  source:  Element/src/multipole.jl:65",
            "title": "enumeratelm(lmax) \u00b6"
        },
        {
            "location": "/Element/#findstepsiarraytuplefloat64-float64-1-ffunction-xlfloat64-xrfloat64-fminint64-fmaxint64",
            "text": "findsteps!(I,f,xl,xr,[fmin,fmax];args=())    like  findsteps  except that the intervals  (x_l,x_r)  are appended to  I .  source:  Element/src/findsteps.jl:35",
            "title": "findsteps!(I::Array{Tuple{Float64, Float64}, 1},  f::Function,  xl::Float64,  xr::Float64,  fmin::Int64,  fmax::Int64) \u00b6"
        },
        {
            "location": "/Element/#findstepsffunction-xlfloat64-xrfloat64",
            "text": "findsteps(f,xl,xr,[fmin,fmax];args=())    takes a function  f(x,args...) , assumed to be a\nmonotonically increasing integer function of  x .  optionally one can specify the range of  f  to search \nwith  fmin ,  fmax  performs a binary search and returns an ordered list of \nintervals  [(x_{l,1},x_{r,1}),(x_{l,2},x_{r,2}),\\dots] \nwithin the specificed range  (xl,xr)  which contains exactly one step.  e.g.  f = (x,c) -  round(Int,x^2+c)\nfindsteps(f,0.0,2.0,args=1.0)  source:  Element/src/findsteps.jl:69",
            "title": "findsteps(f::Function,  xl::Float64,  xr::Float64) \u00b6"
        },
        {
            "location": "/Element/#fzerof-x1float64-x2float64-args",
            "text": "fzero(f,x1,x2,args...;tol=1e-12,maxsteps=100)  finds the root  x_0  of  f(x)  in the interval  [x_1,x_2] , such that f(x_0) = 0  (up to specified tolerance  tol ).  f  - a function f(x,args...) that returns Float64, where extra parameters \nmay be passed through to  f .  throws an error if  f(x_1)  and  f(x_2)  have the same sign, or \nif more than  maxsteps  iterations are taken.  uses the Dekker-Brent method (see  Numerical Recipes in C , p. 361).  source:  Element/src/fzero.jl:17",
            "title": "fzero(f,  x1::Float64,  x2::Float64,  args...) \u00b6"
        },
        {
            "location": "/Element/#genoh_a00v",
            "text": "C version: Dmitri Laikov\n F77 version: Christoph van Wuellen, http://www.ccl.net\n Python version: Richard P. Muller, 2002.\n Julia version: John C. Snyder, 2015.  This subroutine is part of a set of subroutines that generate\n Lebedev grids [1-6] for integration on a sphere. The original \n C-code [1] was kindly provided by Dr. Dmitri N. Laikov and \n translated into fortran by Dr. Christoph van Wuellen.\n This subroutine was translated from C to fortran77 by hand.  Users of this code are asked to include reference [1] in their\n publications, and in the user- and programmers-manuals \n describing their codes.  [1] V.I. Lebedev, and D.N. Laikov\n       'A quadrature formula for the sphere of the 131st\n        algebraic order of accuracy'\n       Doklady Mathematics, Vol. 59, No. 3, 1999, pp. 477-481.  [2] V.I. Lebedev\n       'A quadrature formula for the sphere of 59th algebraic\n        order of accuracy'\n       Russian Acad. Sci. Dokl. Math., Vol. 50, 1995, pp. 283-286.   [3] V.I. Lebedev, and A.L. Skorokhodov\n       'Quadrature formulas of orders 41, 47, and 53 for the sphere'\n       Russian Acad. Sci. Dokl. Math., Vol. 45, 1992, pp. 587-592.   [4] V.I. Lebedev\n       'Spherical quadrature formulas exact to orders 25-29'\n       Siberian Mathematical Journal, Vol. 18, 1977, pp. 99-107.   [5] V.I. Lebedev\n       'Quadratures on a sphere'\n       Computational Mathematics and Mathematical Physics, Vol. 16,\n       1976, pp. 10-24.   [6] V.I. Lebedev\n       'Values of the nodes and weights of ninth to seventeenth \n        order Gauss-Markov quadrature formulae invariant under the \n        octahedron group with inversion'\n       Computational Mathematics and Mathematical Physics, Vol. 15,\n       1975, pp. 44-51.  source:  Element/src/lebedev.jl:49",
            "title": "genOh_a00(v) \u00b6"
        },
        {
            "location": "/Element/#multipolemomentr-rho-l",
            "text": "multipolemoment(r,rho,l)  computes the multipole moment of radial density  rho  in\nthe  l -angular momentum channel   q = \\int dr\\, r^{l+2} \\rho_{lm}(r) .  r  (LogarithmicGrid) - logarithmic grid ( loggrid )  rho  (AbstractVector) - radial density  \\rho_{lm}(r)  evaluated on  r    l  (Int) - l-quantum number  source:  Element/src/radpoisson.jl:70",
            "title": "multipolemoment(r,  rho,  l) \u00b6"
        },
        {
            "location": "/Element/#multistep_integratoryabstractarrayfloat64-1-aabstractarrayfloat64-1-hfloat64-y1float64-y2float64",
            "text": "multistep_integrator!(y,a,h,y1,y2)  is the same as  multistep_integrator ,\nbut overwrites  y .  source:  Element/src/eig.jl:22",
            "title": "multistep_integrator!(y::AbstractArray{Float64, 1},  a::AbstractArray{Float64, 1},  h::Float64,  y1::Float64,  y2::Float64) \u00b6"
        },
        {
            "location": "/Element/#multistep_integratoraabstractarrayfloat64-1-hfloat64-y1float64-y2float64",
            "text": "multistep_integrator(a,h,y1,y2)  solves    y''(x) + a(x) y(x) = 0   on a uniform grid via the 4th order  Numerov's method .  Assuming a uniform grid  [x_1, \\dots, x_n]  with spacing  h  a  - discretization of  a(x) ,  [a(x_1), \\dots, a(x_n)]   y1,y2  - initial boundary condition, specifying  y(x_1)  and  y(x_2)   Returns the solution  [y(x_1), \\dots, y(x_n)] .  source:  Element/src/eig.jl:48",
            "title": "multistep_integrator(a::AbstractArray{Float64, 1},  h::Float64,  y1::Float64,  y2::Float64) \u00b6"
        },
        {
            "location": "/Element/#multistep_integrator_endpointyabstractarrayfloat64-1-aabstractarrayfloat64-1-hfloat64-y1float64-y2float64",
            "text": "multistep_integrator_endpoint(y,a,h,y1,y2)    is the same as  multistep_integrator ,\nbut returns only  y(x_n) .   y  is used as temporary storage.  source:  Element/src/eig.jl:63",
            "title": "multistep_integrator_endpoint(y::AbstractArray{Float64, 1},  a::AbstractArray{Float64, 1},  h::Float64,  y1::Float64,  y2::Float64) \u00b6"
        },
        {
            "location": "/Element/#multistep_integrator_node_countyabstractarrayfloat64-1-aabstractarrayfloat64-1-hfloat64-y1float64-y2float64",
            "text": "multistep_integrator_node_count(y,a,h,y1,y2)    is the same as  multistep_integrator ,\nbut returns the number of nodes in  y(x)  (i.e. the number of sign changes).   y  is used as temporary storage.  source:  Element/src/eig.jl:78",
            "title": "multistep_integrator_node_count(y::AbstractArray{Float64, 1},  a::AbstractArray{Float64, 1},  h::Float64,  y1::Float64,  y2::Float64) \u00b6"
        },
        {
            "location": "/Element/#multistep_rulea_jm1float64-a_jfloat64-a_jp1float64-y_jm1float64-y_jfloat64-hfloat64",
            "text": "multistep_rule(a_jm1,a_j,a_jp1,y_jm1,y_j,h)  computes the multistep rule in Numerov's method:   y_{j+1} = { \\left(2-5h^2 a_j/6\\right)y_j - \\left(1+h^2 a_{j-1}/12\\right)y_{j-1} \n    \\over 1+h^2 a_{j+1}/12 }   source:  Element/src/eig.jl:12",
            "title": "multistep_rule(a_jm1::Float64,  a_j::Float64,  a_jp1::Float64,  y_jm1::Float64,  y_j::Float64,  h::Float64) \u00b6"
        },
        {
            "location": "/Element/#radpoissonrelementlogarithmicgridt-aabstractarrayt-1-rhoabstractarrayt-1-lint64",
            "text": "radpoisson(r,rho,l)  solves the poisson equation for a radial density  rho  in\nthe  l -angular momentum channel  computes the hartree potential   v_{h,lm}(r) = \\int_0^r dr_<\\, r_<^2 g_l(r_<,r) \\rho_{lm}(r_<) + \n    \\int_r^\\infty dr_>\\, r_>^2 g_l(r,r_>) \\rho_{lm}(r_>) ,  where  g_l(r_<,r_>) = r_<^l/r_>^{l+1}   uses a 3rd order adams-moulton multistep integrator to compute\neach integral  r  (LogarithmicGrid) - logarithmic grid ( loggrid )  rho  (AbstractVector) - radial density  \\rho_{lm}(r)  evaluated on  r    l  (Int) - l-quantum number  e.g.  l = 0\nr = loggrid(-13,5,100)\nrho = exp(-2r)\nvh = radpoisson(r,rho,l)\nq = multipolemoment(r,rho,l)\nplot(r,vh)\nplot!(r,q./r.^(l+1))  # asymptotic form of hartree potential\nxlims!(0,10)\nylims!(0,0.3)  [ V. Blum et al., CPC 180 (2009)  p. 2185-2186]  source:  Element/src/radpoisson.jl:41",
            "title": "radpoisson(r::Element.LogarithmicGrid{T, A&lt;:AbstractArray{T, 1}},  rho::AbstractArray{T, 1},  l::Int64) \u00b6"
        },
        {
            "location": "/Element/#radschrodrelementlogarithmicgridfloat64-aabstractarrayt-1-vabstractarrayfloat64-1-nmaxint64-lmaxint64",
            "text": "radschrod(r,v,nmax,lmax;reverse=false,Emin=-1.0,Emax=0.0,Elim=1e4)  solves the radial Schr\u00f6dinger equation   \\left\\{ -{1\\over 2}{d^2\\over dr^2} + {l(l+1)\\over 2r^2} + v(r) \\right\\} u(r) = \\epsilon u(r)   where  \\varphi(r,\\Omega) = {u(r)\\over r} Y_l^m(\\Omega) .  for all eigenvalues/eigenfunctions up to  nmax,lmax  ( nmax   0 ,  lmax  = 0  and  lmax   nmax ).  the eigenfunctions are normalized such that  \\int dr\\, u(r)^2 = 1   r  - logarithmic grid (see  loggrid )  v  - the radial potential  v(r)  evaluated on the grid  r  reverse  - if true, integrate in reverse.   Emin,Emax  - initial  E  interval to search. this will be expanded automatically\n (up to  \u00b1Elim ) until the range includes all requested eigenvalues.  returns  evs,efs,q , the requested eigenvalues, eigenfunctions and a list of \nthe corresponding quantum numbers  n,l  e.g.  hydrogenic atom, Z=1  r = loggrid(-12,5,1000)\nv = -1./r\nnmax,lmax = 3,2\nevs,efs,q = radschrod(r,v,nmax,lmax,reverse=true)  source:  Element/src/radschrod.jl:113",
            "title": "radschrod(r::Element.LogarithmicGrid{Float64, A&lt;:AbstractArray{T, 1}},  v::AbstractArray{Float64, 1},  nmax::Int64,  lmax::Int64) \u00b6"
        },
        {
            "location": "/Element/#radschrod1relementuniformgridfloat64-aabstractarrayt-1-vabstractarrayfloat64-1-nint64-lint64",
            "text": "radschrod1(r,v,n,l;reverse=false,Emin=-1.0,Emax=0.0,Elim=1e4)  solves the radial Schr\u00f6dinger equation   \\left\\{ -{1\\over 2}{d^2\\over dr^2} + {l(l+1)\\over 2r^2} + v(r) \\right\\} u(r) = \\epsilon u(r)   where  \\varphi(r,\\Omega) = {u(r)\\over r} Y_l^m(\\Omega) .  for a single eigenvalue/eigenfunction, specified by  n,l .   the eigenfunction is normalized such that  \\int dr\\, u(r)^2 = 1   r  - uniform grid ( lingrid ,  simpsgrid ) or logarithmic grid ( loggrid )  v  - the radial potential  v(r)  evaluated on the grid  r  reverse  - if true, integrate in reverse.   Emin,Emax  - initial  E  interval to search. this will be expanded automatically\n (up to  \u00b1Elim ) until the range includes all requested eigenvalues.  returns  ev,ef , the requested eigenvalue  \\epsilon  and the eigenfunction  u(r)   e.g.  hydrogen atom 1s orbital  r = loggrid(-12,4,500)\nv = -1./r\nev,ef = radschrod1(r,v,1,0,reverse=true)  source:  Element/src/radschrod.jl:49",
            "title": "radschrod1(r::Element.UniformGrid{Float64, A&lt;:AbstractArray{T, 1}},  v::AbstractArray{Float64, 1},  n::Int64,  l::Int64) \u00b6"
        },
        {
            "location": "/Element/#realsphharmlint64-mint64-real-real",
            "text": "realsphharm(l,m,\u03b8,\u03d5)  computes the real spherical harmonic function    Y_{lm} = {i \\over \\sqrt{2}} \\left(Y_l^m - (-1)^m Y_l^{-m}\\right), \\quad m<0      Y_{lm} = Y_l^m, \\quad m=0      Y_{lm} = {1 \\over \\sqrt{2}} \\left(Y_l^{-m} + (-1)^m Y_l^m\\right), \\quad m>0    source:  Element/src/sphharm.jl:48",
            "title": "realsphharm(l::Int64,  m::Int64,  \u03b8::Real,  \u03d5::Real) \u00b6"
        },
        {
            "location": "/Element/#sphharmlint64-mint64-real-real",
            "text": "sphharm(l,m,\u03b8,\u03d5)  computes the spherical harmonic function (standard definition used in quantum mechanics)    Y_l^m(\\theta,\\phi) = (-1)^m \\sqrt{{2l+1 \\over 4\\pi} {(l-m)!\\over (l+m)!}} P_l^m(cos \\theta) e^{im\\phi}    which are normalized such that     \\int Y_l^m(\\theta,\\phi)^* Y_{l'}^{m'}(\\theta,\\phi) d\\Omega = \\delta_{ll'} \\delta_{mm'}    source:  Element/src/sphharm.jl:32",
            "title": "sphharm(l::Int64,  m::Int64,  \u03b8::Real,  \u03d5::Real) \u00b6"
        },
        {
            "location": "/Element/#splineradialatelementatom",
            "text": "splineradial!(at; npts=100)  splines the electronic density  rho , hartree potential  vh ,\nand Kohn-Sham potential  vs  and creates radial functions.\nAdditionally, the Coulomb potential  v  is created.  assumes the  rho ,  vh  and  vs  have been calculated and are\ngiven in  at  discretized on the radial grid  r .  sets  at[:v]  (see  CoulombPotential )  at[:rho] ,  at[:vh] ,  at[:vs]  (see  RadialFunc ).  npts  - the number of evenly distributed spline points to use  e.g.  at = dft(Z=1.)\nsplineradial!(at)\nplot(at[:rho].u,0,5,label= rho )\nplot!(at[:vh].u,0,5,label= vh )\nplot!(at[:vs].u,0,5,label= vs )\nylims!(-2,1)  source:  Element/src/atom.jl:170",
            "title": "splineradial!(at::Element.Atom) \u00b6"
        },
        {
            "location": "/Element/#elementcoulombpotential",
            "text": "CoulombPotential(Z;R=(0.,0.,0.))  represents the Coulomb potential  v(r) = -Z/|r-R|   source:  Element/src/coulomb.jl:8",
            "title": "Element.CoulombPotential \u00b6"
        },
        {
            "location": "/Element/#elementldaxc",
            "text": "ldaxc  is the pw-lda exchange-correlation functional [1,2].  calls the functionals  XC_LDA_X ,  XC_LDA_C_PW_MOD  in  libxc .  spin-polarized and spin-unpolarized versions \ncan be created via  ldaxcpol()  and  ldaxcunpol()  e.g.  xc = ldaxcunpol()\n\nvx = xc.x.v(rho)  # exchange potential\nex = xc.x.e(rho)  # exchange energy density\nvc = xc.c.v(rho)  # correlation potential\nec = xc.c.e(rho)  # correlation energy density\n\n# in-place versions\nxc.x.v(rho,vx)\nxc.x.e(rho,ex)\nxc.c.v(rho,vc)\nxc.c.e(rho,ec)\n\n# more efficient to compute both together\nxc.x(rho,ex,vx)\nxc.c(rho,ec,vc)\n\n# compute all components\nxc(rho,ex,vx,ec,vc)  [1] J. P. Perdew and Y. Wang. Accurate and simple analytic representation \nof the electron-gas correlation energy. Phys. Rev. B, 45:13244\u201313249, 1992.  [2] D. M. Ceperley and B. J. Alder. Ground state of the electron gas by \na stochastic method. Phys. Rev. Lett., 45:566\u2013569, 1980.  source:  Element/src/xc.jl:177",
            "title": "Element.ldaxc \u00b6"
        }
    ]
}